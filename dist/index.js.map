{"version":3,"sources":["../src/index.ts","../src/core.ts"],"sourcesContent":["import { Engine, installExtensions } from './core';\r\n\r\n// CONSTANTS EXPORT\r\nexport const Grid = 100;\r\nexport const lg = 61.8;\r\nexport const sm = 38.2;\r\nexport const auto = 'auto';\r\n\r\nif (typeof window !== 'undefined') {\r\n  installExtensions();\r\n}\r\n\r\nexport { Engine, installExtensions };\r\nexport * from './core';","/**\r\n * ROWS-COLUMNS-LAYOUT: NATIVE EDITION\r\n */\r\n\r\n// --- TYPES ---\r\nexport interface StyleMap { [key: string]: string | number; }\r\nexport interface SpreadData { t: number, r: number, b: number, l: number; }\r\nexport interface Rule<T> { data: T; indices: number[] | null; }\r\n\r\n// Tracking object for active rules in recursion\r\ninterface ActiveRule<T> {\r\n    rule: Rule<T>;\r\n    counter: { val: number }; // Object reference so it increments across siblings\r\n}\r\n\r\n// CONSTANTS\r\nconst AUTO_SIZE = 0.000001;\r\n\r\n// --- HELPERS ---\r\nfunction parseSpread(directions: string[]): SpreadData {\r\n  const d = { t: 0, r: 0, b: 0, l: 0 };\r\n  directions.forEach(dir => {\r\n    const m = dir.match(/^([trbl])(\\d+)$/);\r\n    if (m) d[m[1] as keyof SpreadData] += parseInt(m[2], 10);\r\n  });\r\n  return d;\r\n}\r\n\r\n// --- 1. CORE CLASSES ---\r\nexport class LayoutNode {\r\n  constructor(\r\n    public size: number | string,\r\n    public type: 'leaf' | 'col' | 'row' = 'leaf',\r\n    public children: any[] = []\r\n  ) {}\r\n\r\n  isSkippedSelf = false;\r\n  offsetIndices: number[] = [];\r\n  \r\n  styles: StyleMap = {}; \r\n  spreadData: SpreadData = { t:0, r:0, b:0, l:0 }; \r\n\r\n  // Rules targeting scoped children\r\n  childPropRules: Rule<StyleMap>[] = [];\r\n  childSpreadRules: Rule<SpreadData>[] = [];\r\n\r\n  col(...children: any[]) { return new LayoutNode(this.size, 'col', children); }\r\n  row(...children: any[]) { return new LayoutNode(this.size, 'row', children); }\r\n\r\n  offset(indices?: number[]) {\r\n    if (Array.isArray(indices)) this.offsetIndices = indices;\r\n    else this.isSkippedSelf = true;\r\n    return this;\r\n  }\r\n\r\n  props(s: StyleMap) { this.styles = { ...this.styles, ...s }; return this; }\r\n  \r\n  childProps(style: StyleMap, indices?: number[]) {\r\n    this.childPropRules.push({ data: style, indices: indices || null });\r\n    return this;\r\n  }\r\n\r\n  spread(directions: string[], indices?: number[]) {\r\n    if (indices) {\r\n      this.childSpreadRules.push({ data: parseSpread(directions), indices });\r\n    } else {\r\n      const data = parseSpread(directions);\r\n      this.spreadData.t += data.t;\r\n      this.spreadData.r += data.r;\r\n      this.spreadData.b += data.b;\r\n      this.spreadData.l += data.l;\r\n    }\r\n    return this;\r\n  }\r\n}\r\n\r\nexport class Rect {\r\n  constructor(\r\n    public x: number, public y: number, public w: number, public h: number,\r\n    public styles: any, public isSkipped: boolean, \r\n    public customSize?: string,\r\n    public spread: SpreadData = {t:0,r:0,b:0,l:0}\r\n  ) {}\r\n}\r\n\r\n// --- 2. PROTOTYPE EXTENSIONS ---\r\ndeclare global {\r\n  interface Number { col(...a:any):LayoutNode; row(...a:any):LayoutNode; offset(a?:any):LayoutNode; props(s:any):LayoutNode; childProps(s:any,a?:any):LayoutNode; spread(a:string[], i?:number[]):LayoutNode; }\r\n  interface String { col(...a:any):LayoutNode; row(...a:any):LayoutNode; offset(a?:any):LayoutNode; props(s:any):LayoutNode; childProps(s:any,a?:any):LayoutNode; spread(a:string[], i?:number[]):LayoutNode; }\r\n  interface Window { [key:string]: any }\r\n}\r\n\r\nlet installed = false;\r\nexport function installExtensions() {\r\n  if (installed) return; installed = true;\r\n  const n = (v: number | string) => new LayoutNode(v);\r\n  const setup = (Proto: any, isStr = false) => {\r\n    if (Proto.col) return;\r\n    const w = (ctx: any) => n(isStr ? String(ctx) : ctx);\r\n    Proto.col = function(...a:any[]) { return new LayoutNode(isStr ? String(this) : this, 'col', a); };\r\n    Proto.row = function(...a:any[]) { return new LayoutNode(isStr ? String(this) : this, 'row', a); };\r\n    Proto.offset = function(a?:any) { return w(this).offset(a); };\r\n    Proto.props = function(s:any) { return w(this).props(s); };\r\n    Proto.childProps = function(s:any, a?:any) { return w(this).childProps(s, a); };\r\n    Proto.spread = function(a:string[], i?:number[]) { return w(this).spread(a, i); };\r\n  };\r\n  setup(Number.prototype, false);\r\n  setup(String.prototype, true);\r\n}\r\n\r\n// --- 3. THE ENGINE ---\r\nexport const Engine = {\r\n  bps: { sm: 576, md: 768, lg: 992, xl: 1200, xxl: 1400 } as any,\r\n  _strMap: new Map<number, string>(),\r\n  _strCounter: 0,\r\n\r\n  init() {\r\n    installExtensions();\r\n    this.upd();\r\n    if (typeof window !== 'undefined') window.addEventListener('resize', () => this.upd());\r\n  },\r\n\r\n  upd() {\r\n    if (typeof document !== 'undefined') document.querySelectorAll('[layout]').forEach(el => this.render(el as HTMLElement));\r\n  },\r\n\r\n  evalLayout(str: string): LayoutNode | undefined {\r\n    if (!str) return undefined;\r\n    try {\r\n      const func = new Function('lg', 'sm', 'Grid', 'auto', 'return ' + str);\r\n      return func(61.8, 38.2, 100, 'auto');\r\n    } catch (e) {\r\n      console.error(`Layout Error: \"${str}\"`, e);\r\n      return undefined;\r\n    }\r\n  },\r\n\r\n  isNode(n: any): boolean {\r\n    return n && typeof n === 'object' && Array.isArray(n.children) && (n.type === 'col' || n.type === 'row' || n.type === 'leaf');\r\n  },\r\n\r\n  render(el: HTMLElement, direct?: LayoutNode) {\r\n    installExtensions();\r\n    let tree = direct;\r\n    if (!tree) {\r\n      const w = window.innerWidth;\r\n      const bps = ['xxl', 'xl', 'lg', 'md', 'sm'];\r\n      let attr = el.getAttribute('layout');\r\n      for (let b of bps) if (w >= this.bps[b] && el.hasAttribute(`layout-${b}`)) { attr = el.getAttribute(`layout-${b}`); break; }\r\n      if (attr) tree = this.evalLayout(attr);\r\n    }\r\n    if (!tree) return;\r\n\r\n    if (tree.styles) Object.assign(el.style, tree.styles);\r\n\r\n    const leaves: Rect[] = [];\r\n    \r\n    // START RECURSION\r\n    // We pass empty arrays for active rules. \r\n    this.calc(tree, 0, 0, 100, 100, leaves, false, [], [], []);\r\n\r\n    const { cw, rh, xc, yc } = this.mesh(leaves);\r\n    el.style.display = \"grid\";\r\n    el.style.gridTemplateColumns = cw.join(' ');\r\n    el.style.gridTemplateRows = rh.join(' ');\r\n\r\n    const kids = Array.from(el.children) as HTMLElement[];\r\n    kids.forEach((k) => { k.style.gridColumn=''; k.style.gridRow=''; k.style.cssText=''; });\r\n\r\n    let kidIdx = 0;\r\n    leaves.forEach(l => {\r\n       if (l.isSkipped) return;\r\n       if (!kids[kidIdx]) return;\r\n       const k = kids[kidIdx++];\r\n       \r\n       let cs = this.idx(xc, l.x) + 1;\r\n       let ce = this.idx(xc, l.x + l.w) + 1;\r\n       let rs = this.idx(yc, l.y) + 1;\r\n       let re = this.idx(yc, l.y + l.h) + 1;\r\n\r\n       // APPLY SPREAD\r\n       if (l.spread) {\r\n           cs = Math.max(1, cs - l.spread.l);\r\n           rs = Math.max(1, rs - l.spread.t);\r\n           ce += l.spread.r;\r\n           re += l.spread.b;\r\n       }\r\n\r\n       k.style.gridColumn = `${cs} / ${ce}`;\r\n       k.style.gridRow = `${rs} / ${re}`;\r\n       \r\n       if (l.styles) Object.assign(k.style, l.styles);\r\n    });\r\n  },\r\n\r\n  calc(\r\n      n: any, x: number, y: number, w: number, h: number, \r\n      leaves: Rect[], pSkip: boolean, offRules: any[], \r\n      \r\n      // TRACKING STACKS\r\n      activePropRules: ActiveRule<StyleMap>[],\r\n      activeSpreadRules: ActiveRule<SpreadData>[]\r\n  ) {\r\n    if (!n) return;\r\n    if (typeof n === 'number' || n === 'auto') n = new LayoutNode(n === 'auto' ? 'auto' : n, 'leaf');\r\n\r\n    const isLayoutNode = this.isNode(n);\r\n    const skip = pSkip || (isLayoutNode && n.isSkippedSelf);\r\n    \r\n    // 1. Manage Offsets (Local to this node)\r\n    const offs = [...offRules];\r\n    if (isLayoutNode && n.offsetIndices?.length) offs.push({ idx: n.offsetIndices, c: 0 });\r\n\r\n    let customSize = undefined;\r\n    if (isLayoutNode && typeof n.size === 'string') customSize = n.size;\r\n    \r\n    // 2. PREPARE NEW RULES\r\n    // If this node defines rules, create NEW trackers starting at 0\r\n    const nextPropRules = [...activePropRules];\r\n    const nextSpreadRules = [...activeSpreadRules];\r\n\r\n    if (isLayoutNode) {\r\n        if(n.childPropRules.length > 0) {\r\n            n.childPropRules.forEach((r: any) => nextPropRules.push({ rule: r, counter: {val: 0} }));\r\n        }\r\n        if(n.childSpreadRules.length > 0) {\r\n            n.childSpreadRules.forEach((r: any) => nextSpreadRules.push({ rule: r, counter: {val: 0} }));\r\n        }\r\n    }\r\n\r\n    // --- LEAF NODE LOGIC ---\r\n    if (!isLayoutNode || !n.children.length) {\r\n       // A. Calculate if this leaf is skipped by offset\r\n       let finalSkip = skip;\r\n       offs.forEach(r => { r.c++; if (r.idx.includes(r.c)) finalSkip = true; });\r\n\r\n       // B. If NOT skipped, it counts as a visual child for all active rules\r\n       //    So we increment their counters.\r\n       if (!finalSkip) {\r\n           nextPropRules.forEach(t => t.counter.val++);\r\n           nextSpreadRules.forEach(t => t.counter.val++);\r\n       }\r\n\r\n       // C. Calculate Intrinsic Spread (Self) + Rule-Based Spread (Ancestors)\r\n       const finalSpread = isLayoutNode ? { ...n.spreadData } : {t:0,r:0,b:0,l:0};\r\n\r\n       if (!finalSkip) {\r\n           nextSpreadRules.forEach(tracker => {\r\n               if (!tracker.rule.indices || tracker.rule.indices.includes(tracker.counter.val)) {\r\n                   finalSpread.t += tracker.rule.data.t;\r\n                   finalSpread.r += tracker.rule.data.r;\r\n                   finalSpread.b += tracker.rule.data.b;\r\n                   finalSpread.l += tracker.rule.data.l;\r\n               }\r\n           });\r\n       }\r\n\r\n       // D. Calculate Styles\r\n       const finalStyles = isLayoutNode ? { ...n.styles } : {};\r\n       if (!finalSkip) {\r\n           nextPropRules.forEach(tracker => {\r\n               if (!tracker.rule.indices || tracker.rule.indices.includes(tracker.counter.val)) {\r\n                   Object.assign(finalStyles, tracker.rule.data);\r\n               }\r\n           });\r\n       }\r\n\r\n       leaves.push(new Rect(x, y, w, h, finalStyles, finalSkip, customSize, finalSpread));\r\n       return;\r\n    }\r\n\r\n    // --- CONTAINER LOGIC ---\r\n    let tw = 0;\r\n    n.children.forEach((c: any) => {\r\n       let s = this.isNode(c) ? c.size : c;\r\n       if (typeof s === 'string') s = 0;\r\n       else if (this.isNode(c) && c.size === 0) s = 1; \r\n       tw += Number(s);\r\n    });\r\n    if(tw === 0) tw = 1; \r\n\r\n    let pos = (n.type === 'col') ? x : y;\r\n    \r\n    n.children.forEach((c: any, i: number) => {\r\n       let s = this.isNode(c) ? c.size : c;\r\n       let isString = (typeof s === 'string');\r\n       let numSize = isString ? 0 : Number(s);\r\n       if (this.isNode(c) && c.size === 0 && !isString) numSize = 1;\r\n       let r = numSize / tw; \r\n\r\n       let stringWidth = 0;\r\n       if (isString) {\r\n           this._strCounter++;\r\n           stringWidth = AUTO_SIZE + (this._strCounter * 0.0000001);\r\n           this._strMap.set(stringWidth, s as string); \r\n       }\r\n\r\n       if (n.type === 'col') {\r\n          let cw = isString ? stringWidth : (w * r);\r\n          this.calc(c, pos, y, cw, h, leaves, skip, offs, nextPropRules, nextSpreadRules); \r\n          pos += cw;\r\n       } else {\r\n          let ch = isString ? stringWidth : (h * r);\r\n          this.calc(c, x, pos, w, ch, leaves, skip, offs, nextPropRules, nextSpreadRules); \r\n          pos += ch;\r\n       }\r\n    });\r\n  },\r\n\r\n  mesh(leaves: Rect[]) {\r\n    this._strCounter = 0; \r\n    let rx = [0], ry = [0]; \r\n    let maxX = 0, maxY = 0;\r\n    leaves.forEach(r => { \r\n        rx.push(r.x, r.x + r.w); ry.push(r.y, r.y + r.h); \r\n        if(r.x + r.w > maxX) maxX = r.x + r.w;\r\n        if(r.y + r.h > maxY) maxY = r.y + r.h;\r\n    });\r\n    if (maxX > 1) rx.push(100); if (maxY > 1) ry.push(100);\r\n\r\n    const dedup = (arr: number[]) => [...new Set(arr.sort((a,b)=>a-b))].filter((v,i,s)=>i===0|| Math.abs(v-s[i-1]) > 0.00000001);\r\n    const xc = dedup(rx);\r\n    const yc = dedup(ry);\r\n\r\n    const getTracks = (cuts: number[]) => {\r\n        const tracks = [];\r\n        for(let i=1; i<cuts.length; i++) {\r\n            let size = cuts[i] - cuts[i-1];\r\n            let found = null;\r\n            for (let [k, v] of this._strMap) { if (Math.abs(size - k) < 0.00000001) { found = v; break; } }\r\n            tracks.push(found ? found : size + 'fr');\r\n        }\r\n        return tracks;\r\n    };\r\n    return { xc, yc, cw: getTracks(xc), rh: getTracks(yc) };\r\n  },\r\n\r\n  idx(arr: number[], val: number) {\r\n    let idx = -1, min = Infinity;\r\n    arr.forEach((v, i) => { let d = Math.abs(v - val); if (d < min) { min = d; idx = i; } });\r\n    return idx;\r\n  }\r\n};"],"mappings":"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","names":[]}