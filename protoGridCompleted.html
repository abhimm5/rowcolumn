<!DOCTYPE html>
<html>
    <head>
        <style id="dcoder_stylesheet" type="text/css">
            .grid-container>div {
      border: 1px solid #ccc;
    }
    body {
      margin: 0;
      padding: 0;
    }
        </style>
    </head>
    <body>
        <div class="grid-container" id="grid-container" layout="(100).splits(lg.splits(lg.splits(lg,sm.splits(sm,lg,'perpendicular') ,'parallel'),sm ,'perpendicular'), sm.splits(sm,lg,'parallel'),'perpendicular')">
            <div>
                1
            </div>
            <div>
                2
            </div>
            <div>
                3
            </div>
            <div>
                4
            </div>
            <div>
                5
            </div>
            <div>
                6
            </div>
            <div>
                7
            </div>
            <div>
                8
            </div>
            <div>
                9
            </div>
            <div>
                10
            </div>
            <div>
                11
            </div>
            <div>
                12
            </div>
            <div>
                13
            </div>
            <div>
                14
            </div>
            <div>
                15
            </div>
            <div>
                16
            </div>
            <div>
                17
            </div>
        </div>
        <script type="text/javascript">
            let parent = 100;
  let lg = 61.2;
  let sm = 38.8;

  function Grid(parent) {
  this.gridParent = parent;
  this.gridParent.style.display = "grid";
  
}

Grid.prototype.cartesianSystem = function(x, y) {
  function addUnits(array, units) {
    const iterator = array.values();
    const newarr = [];
    for (const value of iterator) {
      newarr.push(value + units);
    }
    return newarr.join(" ");
  }
  this.gridParent.style.gridTemplateColumns = addUnits(x, "%");
  this.gridParent.style.gridTemplateRows = addUnits(y, "vh");
};

Grid.prototype.assignCoordinate = function(item, coordinates) {
  let [x1, y1, x2, y2] = coordinates;
  this.getGridBox = item;
  this.getGridBox.style.gridRowStart = x1;
  this.getGridBox.style.gridColumnStart = y1;
  this.getGridBox.style.gridRowEnd = x2;
  this.getGridBox.style.gridColumnEnd = y2;
  this.getGridBox.style.color = "red";
};


  function restructure(primaryValue,left,right,direction){
    //console.log(left)
    let x = { left: primaryValue, right: primaryValue, direction: "perpendicular"}
    let y = { left: primaryValue, right: primaryValue, direction: "parallel" }
    if(direction == "perpendicular"){
      x = { left: left, right: right, direction: "perpendicular"}
    }
    if(direction == "parallel"){
      y = { left: left, right: right, direction: "parallel"}
    }
    return [x,y]
  }
  Number.prototype.splits = function (a, b, c) {
    [this.left, this.right, this.direction] = arguments;
    return this
  }
  Number.prototype.rearrange = function(axis,point,distance){
    let sum = Number(this.left) + Number(this.right)
    let parent = this.valueOf()
    let left = Math.round((parent/sum * Number(this.left)))
    let right =  Math.round((parent/sum * Number(this.right)))
    let x, y
    this.dimension = [left,right]


    if(axis){
      if(this.direction=="perpendicular"){
        axis[0].left = left
        axis[0].right = right
      }
      if(this.direction == "parallel"){
        axis[1].left = left
        axis[1].right = right
      }
      this.axis = axis     
    }
    else{
      this.axis = restructure(left+right,left,right,this.direction)
    }
    function reviseAxis(axis,value,direction,extras){
      axis.map(getParent =>{
        if(getParent.direction == direction){
          if(extras){
            getParent.left = extras[0] 
            getParent.right = extras[1] 
          }
          else{
            getParent.left = value 
            getParent.right = value
          }
        }
      })
      return axis
    }
    function revisePoint(point,value,direction,addition){
      if(addition){
        if(direction === "perpendicular"){
          point[0].x = point[0].x + value
        }
        if(direction === "parallel"){
          point[0].y = point[0].y + value
        }
        
      }
      if(!addition){
        if(direction === "perpendicular"){
          point[0].x =  value
        }
        if(direction === "parallel"){
          point[0].y = value
        }
      }
      return point
    }

    
    
    if(point){
      let oldPoint = JSON.parse(JSON.stringify(point))
      myPoint = revisePoint(oldPoint,left,this.direction,true)
    }
    else{
      let p = [{x:0,y:0}]
      myPoint = revisePoint(p,left,this.direction)
    }

    
    


    function reviseDistance(position,direction){
      console.log(position)
      let cutOnAxes = position
      if(direction == "perpendicular"){
        console.log(position,this.x)
        x.push(cutOnAxes[0].x)
      }
      if(direction == "parallel"){
        y.push(cutOnAxes[0].y)
      }
      
    }

    this.position = JSON.parse(JSON.stringify(myPoint))
    
    if(distance){
      [x,y] =  distance
      reviseDistance(this.position,this.direction)
    }
    else{
      x = []
      y = []
      reviseDistance(this.position,this.direction)
    }
    
    let getPerpendicular = this.axis[0]
    let getParallel = this.axis[1]
    
      if(typeof this.left == 'object'){
        let xl = getPerpendicular.left.splits((this.left.left),(this.left.right),this.left.direction)
        let yl = getParallel.left.splits((this.left.left),(this.left.right),this.left.direction) 
        let newAxisX = [{ left: Number(left)  , right: Number(right) , direction: "perpendicular" },this.axis[1]]
        let newAxisY = [this.axis[0],{ left: Number(left), right: Number(right), direction: "parallel" }]
        //let newPoint = JSON.parse(JSON.stringify(point))
        
        if(this.left.direction !== this.direction && this.left.direction == 'perpendicular'){
         
          let newAxisX2 = JSON.parse(JSON.stringify(newAxisX))
          newAxisX2.map(getParent =>{
            if(getParent.direction==this.direction){
              getParent.left = left
              getParent.right = left
            }
          })
          if(point){
            this.left = xl.rearrange(newAxisX2,point,[x,y])
          }
          else{
            this.left = xl.rearrange(newAxisX2,null,[x,y])
          }
        }
        else if(this.left.direction !== this.direction && this.left.direction == 'parallel'){

          //console.log(true)
          let newAxisY2 = JSON.parse(JSON.stringify(newAxisY))
          newAxisY2.map(getParent =>{
            if(getParent.direction==this.direction){
              getParent.left = left
              getParent.right = left
            }
          })
          if(point){
            console.log('aaa')
            this.left = yl.rearrange(newAxisY2,point,[x,y])
          }
          else{
            console.log('bbb')
            this.left = yl.rearrange(newAxisY2,null,[x,y])
          }
          
        }
        else{
          if(point){
            this.left = this.left.direction == 'perpendicular'? xl.rearrange(newAxisX,point,[x,y]):yl.rearrange(newAxisY,point,[x,y])
          }
          else{
            this.left = this.left.direction == 'perpendicular'? xl.rearrange(newAxisX,null,[x,y]):yl.rearrange(newAxisY,null,[x,y])
          }
          //this.left = this.left.direction == 'perpendicular'? xl.rearrange(newAxisX,point,[x,y]):yl.rearrange(newAxisY,point,[x,y])
        }
      }
      else{
        this.left = this.dimension[0]
      }
      if(typeof this.right == 'object'){
        let xr = getPerpendicular.right.splits((this.right.left),(this.right.right),this.right.direction)
        let yr = getParallel.right.splits((this.right.left),(this.right.right),this.right.direction)
        let newAxisX = [{ left: Number(left), right: Number(right), direction: "perpendicular" },this.axis[1]]
        let newAxisY = [this.axis[0],{ left: Number(left), right: Number(right), direction: "parallel" }]
        let newPoint = JSON.parse(JSON.stringify(this.position))

        if(this.right.direction !== this.direction && this.right.direction == 'perpendicular'){
          let newPoint = JSON.parse(JSON.stringify(this.position))
          let newAxisX2 = JSON.parse(JSON.stringify(newAxisX))
          newAxisX2.map(getParent =>{
            if(getParent.direction==this.direction){
              getParent.left = right
              getParent.right = right
            }
          })
          if(point){
            this.right = xr.rearrange(newAxisX2,newPoint,[x,y])
          }
          else{
            this.right = xr.rearrange(newAxisX2,newPoint,[x,y])
          }
        }
        else if(this.right.direction !== this.direction && this.right.direction == 'parallel'){
          let newPoint = JSON.parse(JSON.stringify(this.position))
          let newAxisY2 = JSON.parse(JSON.stringify(newAxisY))
          newAxisY2.map(getParent =>{
            if(getParent.direction==this.direction){
              getParent.left = right
              getParent.right = right
            }
          })
          if(point){
            this.right = yr.rearrange(newAxisY2,newPoint,[x,y])
          }
          else{
            this.right = yr.rearrange(newAxisY2,newPoint,[x,y])
          }
        }
        else{
         
            this.right = this.right.direction == 'perpendicular'? xr.rearrange(newAxisX,newPoint,[x,y]):yr.rearrange(newAxisY,newPoint,[x,y])
        }
        
      }
      else{
        this.right = this.dimension[1]
      }
      x.unshift(0,100)
      y.unshift(0,100)
      let xsorted = x.sort(function(a, b){return a-b})
      let ysorted = y.sort(function(a, b){return a-b})
      x = Array.from(new Set(xsorted))
      y = Array.from(new Set(ysorted))

      
      this.gridTemplateColumns = []
      this.gridTemplateRows = []
      x.map((value,index,array) =>{
        let num = array[index+1]-value;
        this.gridTemplateColumns.push(num)
      })
      y.map((value,index,array) =>{
        let num = array[index+1]-value;
        this.gridTemplateRows.push(num)
       
      })
      //console.log(x,y)
      //console.log(this.x,this.y)
      const removeItems = (array, itemToRemove) => { 
          return array.filter(v => { 
          return !itemToRemove.includes(v); 
        });
      }
      this.x = x.filter((item,index) => x.indexOf(item) === index)
      this.y = y.filter((item,index) => y.indexOf(item) === index) 
      
      delete this.dimension
      this.gridTemplateColumns = removeItems(this.gridTemplateColumns, [0,NaN])
      this.gridTemplateRows = removeItems(this.gridTemplateRows, [0,NaN])
      //console.log(this.x,this.y)
      console.log(this.gridTemplateColumns,this.gridTemplateRows)
    return this
  }
 Number.prototype.devise = function(coordinates,length){
  let presetArea, thislength
  if(!coordinates){
    let defaultArea = [1,1,2,2]
    presetArea = defaultArea 
  }
  if(coordinates){
    presetArea = coordinates
  }
  if(length){
    thislength = length
  }
  else{
    thislength = [this.x,this.y]
  }

  let toRealObject = (object) => {
    let keys = Object.keys(object)
    let values = Object.values(object)
    let newObject = {} 
    keys.forEach((element,index) => { newObject[element] = values[index] })
    return newObject;
  }

    let countDirection = (object,direction,countArray) => {
      let numberOfDirection
      let stack = toRealObject(object)
      if(countArray){
        numberOfDirection = countArray
      }
      else{
        numberOfDirection = []
      }
      numberOfDirection.push(stack.direction)
      for(let key in stack){
        if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
          countDirection(stack[key],stack[key].direction,numberOfDirection)
        }
      }
      return numberOfDirection.filter(element => element !== undefined)
    }
    let countPosition = (object,direction,countArray) => {
      //console.log(object.point[0])
      let stack = toRealObject(object)
      let numberOfPoint
      if(countArray){
        numberOfPoint = countArray
      }
      else{
        numberOfPoint = []
      }
      numberOfPoint.push(stack.position)
      for(let key in stack){
        if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
          countPosition(stack[key],stack[key].direction,numberOfPoint)
        }
      }
      return numberOfPoint.filter(element => element !== undefined)
    }
    let getDirection = (result) => {
      return result.filter((item,index) => result.indexOf(item) === index).map(value => value.replace(/[0-9]/g, ''))
    }
    let getPosition = (result) => {
      return result.filter((item,index) => result.indexOf(item) === index).map(value => value.replace(/\D/g,''))
    }
    let identify = (area,callback) => {
      //debug point in count direction.
      let numOfDir =  countDirection(area)
      let numOfPos = countPosition(area)
      let result = []
      numOfDir.forEach((value,index) => {
        if(value == 'perpendicular'){
          result.push(value + numOfPos[index][0].x)
        }
        if(value == 'parallel'){
          result.push(value + numOfPos[index][0].y)
        }
      })
      return callback(result)
    }
    let identifyDirection = (area,callback) => {
      let numOfDir =  identify(area,getDirection)
      //console.log(numOfDir)
      let substitutionX = numOfDir.filter(element => element =="perpendicular").length
      let substitutionY = numOfDir.filter(element => element =="parallel").length
      
      return [substitutionX,substitutionY]
    }

    
     let composeArea = (direction,coordinates,gridArea,value) => {
      [x1,y1,x2,y2] = coordinates
      if(value == 0){
        if(gridArea == 'L'){
        if (direction == 'parallel'||direction == 1) {
          x2=x2-1
        }
        if (direction == 'perpendicular'||direction == 0) {
          y2= y2-1
        }
        return [x1,y1,x2,y2]
      }
      if(gridArea == 'R'){
        if (direction == 'parallel'||direction == 1) {
          x1 =x1+1
        }
        if (direction == 'perpendicular'||direction == 0) {
           y1 = y1+1
        }
        return [x1,y1,x2,y2]
      }
      }
      else if(value > 0){
        if(gridArea == 'L'){
        if (direction == 'parallel'||direction == 1) {
          x2=x2-(1 +value)
        }
        if (direction == 'perpendicular'||direction == 0) {
          y2= y2-(1 +value)
        }
        return [x1,y1,x2,y2]
      }
      if(gridArea == 'R'){
        if (direction == 'parallel'||direction == 1) {
          x1 =x1+(1 +value)
        }
        if (direction == 'perpendicular'||direction == 0) {
           y1 = y1+(1 +value)
        }
        return [x1,y1,x2,y2]
      }
      }
    }

    let reviseArea = (object,gridAreaName,length) => {
      let direction = object.direction;
      let lc = object.leftGridArea;
      let rc = object.rightGridArea;
      let left = object.left
      let right = object.right
      let thislength  = object.direction == 'perpendicular' ? array = length[0] : array = length[1]
      let getValues = (array,from,to) => {
        return array.slice(array.indexOf(from)+1, array.indexOf(to))
      }
      let getPosition = direction => {
        if(direction == 'perpendicular'){
          return Object.values(object.position[0])[0]
        }
        if(direction == 'parallel'){
          return Object.values(object.position[0])[1]
        }
      }
      let getAxis = direction => object.axis.filter( value => {
        if(value.direction == direction){
          return value
        }
      })
      let p = getPosition(object.direction)
      let l = p - getAxis(direction)[0].left
      let r = p + getAxis(direction)[0].right
      let directionOnLeft = getValues(thislength,l,p).length
      let directionOnRight = getValues(thislength,p,r).length
      //console.log(object.direction)
      //console.log(directionOnLeft,directionOnRight,gridAreaName)

      //console.log(composeArea(object.direction,object.gridArea,gridAreaName,directionOnRight),'<-',object.gridArea,'->',composeArea(object.direction,object.gridArea,gridAreaName,directionOnLeft))
      if(gridAreaName == "L"){
        return composeArea(object.direction,object.gridArea,gridAreaName,directionOnRight)
      }
      if(gridAreaName == "R"){
        //console.log(p,l,r,thislength,direction)
        return composeArea(object.direction,object.gridArea,gridAreaName,directionOnLeft)       
      }
    }
    
    let [x1,y1,x2,y2] = presetArea
    let endCoordinates = identifyDirection(this)
    x2 = x2 + endCoordinates[1]
    y2 = y2 + endCoordinates[0]
    this.gridArea = coordinates ? this.gridArea = coordinates :this.gridArea = [x1,y1,x2,y2]
    //console.log(endCoordinates,[x1,y1,x2,y2],presetArea,thisArea)
    //console.log(this.gridArea,identifyDirection(this))
    //console.log(this.leftGridArea,this.rightGridArea)
    
  if(typeof this.left == 'object'){
    
    let newArea = reviseArea(this,'L',thislength)
    //console.log(this.gridArea,coordinates,newArea)
    if(coordinates){
      //console.log(true)
      this.left.devise(newArea,thislength)
    }
    else{
      this.left.devise(newArea,thislength)
    }
  }
  else{
    //console.log(true)
    this.leftGridArea = reviseArea(this,'L',thislength)
    this.left
  }
  if(typeof this.right == 'object'){
    let newArea = reviseArea(this,'R',thislength)
    if(coordinates){
      this.right.devise(newArea,thislength)
    }
    else{
      //console.log(true)
      this.right.devise(newArea,thislength)
    }
  }
  else{
    //console.log(this.gridArea)
    this.rightGridArea =  reviseArea(this,'R',thislength)
    this.right
  }
  return this
 }

 Number.prototype.extract = function(){
    let object = this
    let coordinates = new Array;
    function extractCoordinates(mat,recur){
      let stack = Object.values(mat);
      if(Number.isFinite(mat.left)){
        coordinates.push(mat.leftGridArea)
      }
      if(Number.isFinite(mat.right)){
        coordinates.push(mat.rightGridArea)
      }
      for (let key in stack) {
        if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
         extractCoordinates(stack[key])
        }
      }
    }
   extractCoordinates(this)
   return coordinates
  }
  

  let test2 = (100).splits(lg.splits(lg.splits(lg.splits(sm,lg,'perpendicular'),sm.splits(sm,lg,'perpendicular') ,'parallel'),sm ,'perpendicular'), sm.splits(sm,lg,'parallel'),'perpendicular')
  let test1 = (100).splits(lg.splits(lg,sm ,'perpendicular'), sm.splits(lg,sm ,'parallel'),'perpendicular')
  let test3 = (100).splits(lg.splits(lg,sm.splits(lg,sm ,'perpendicular') ,'parallel'), sm,'perpendicular')
  let test4a = (100).splits(3/12,(9/12).splits(3/12,6/12,"parallel"),'perpendicular')
  let test4b = (100).splits(3/12,(9/12).splits(3/12,6/12,"parallel"),'perpendicular')
  let test5 = (100).splits(lg.splits(lg,sm,"parallel"),sm.splits(lg,sm,"parallel"),'perpendicular')
  let test6 = (100).splits(lg,sm.splits(lg,sm,"parallel"),'perpendicular') //basic
  let test7 = (100).splits(lg.splits(lg.splits(lg,sm.splits(sm,lg,'perpendicular') ,'parallel'),sm ,'perpendicular'), sm.splits(sm,lg,'parallel'),'perpendicular')
  let test8 = (100).splits(lg.splits(lg.splits(lg,sm,'perpendicular'),sm,'perpendicular'), sm.splits(lg,sm ,'perpendicular') ,'perpendicular') //all one direction
  let test9 = (100).splits(lg.splits(sm,lg,'parallel'),sm.splits(lg,sm.splits(lg,sm,'perpendicular'),'parallel'),'perpendicular')
  let test10imp = (100).splits(lg.splits(lg.splits(lg,sm,"perpendicular"),sm.splits(lg.splits(lg,sm,"parallel"),sm,"perpendicular"),"parallel"), sm.splits(sm.splits(lg.splits(lg,sm,"parallel"),sm,"perpendicular"),lg.splits(lg,sm.splits(lg,sm,"parallel"),"perpendicular"),"parallel"),'perpendicular')
  let test10impb = (100).splits(lg.splits(lg.splits(lg,sm,"perpendicular"),sm.splits(lg.splits(lg,sm,"parallel"),sm,"perpendicular"),"parallel"), sm.splits(lg.splits(lg.splits(lg,sm,"parallel"),sm,"perpendicular"),sm.splits(lg,sm.splits(lg,sm,"parallel"),"perpendicular"),"parallel"),'perpendicular')
  //console.log((100).splits(lg.splits(lg,sm,"perpendicular"),sm.splits(lg,sm,"parallel"),'parallel').rearrange())
  let test11imp = (100).splits(lg, sm.splits(lg.splits(lg,sm,"parallel"),sm.splits(lg,sm,"perpendicular"),"perpendicular"),'perpendicular')
  function set(values){
  let o = values.rearrange().devise()  //add devise
  let col = o.gridTemplateColumns;
  let row = o.gridTemplateRows;
  let cor = o.extract()
  const nodeList = document.querySelectorAll("div[layout]");
  console.log(o)
  console.log(col,row)
  console.log(cor)
  console.log(nodeList[0])
  let getdiv = nodeList[0]
  let grid = new Grid(nodeList[0])
  cor.forEach((value,index) => {
    grid.cartesianSystem(col,row)
    grid.assignCoordinate(getdiv.children[index],value)
  })
  }
let test10 = (100).splits(lg.splits(lg,sm,"perpendicular"),sm.splits(lg,sm,"parallel"),'parallel')

  set((100).splits(3/12,(9/12).splits(3/12,6/12,"parallel"),'perpendicular')
        </script>
    </body>
</html>


