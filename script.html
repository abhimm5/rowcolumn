<!DOCTYPE html>
<html>

<head>
  <style type="text/css" id="dcoder_stylesheet">
    .grid-container>div {
      border: 1px solid #ccc;
    }
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>

  <div class="grid-container" id="grid-container" layout="(100).splits(lg.splits(sm,lg,'parallel'),sm.splits(lg,sm.splits(lg,sm,'perpendicular'),'parallel'),'perpendicular')">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
  </div>

 

<script type="text/javascript">

  // let vtotal = v.length + 1
  // let htotal = h.length + 1

    let priVal = 100
    const ratio = 1.618;
    const parent = 100;
    const lg = 61.2;
    const sm = 38.8;

    const vp = ["vw", "vh"];
    const directionKeywords = ["perpendicular", "parallel", "both", "none"];
    const units = ["vh", "%", "em"];
    const baseNums = [38.2, 61.8, 100, 1.618, 0];
    const functionOrder = ["left", "right", "direction", "rotation", "modify", "clear"];
    const gridKeywords = ['verGrids', 'horGrids']
    Number.prototype.splits = function (a, b, c) {
      if (!arguments) { return }
      [this.left, this.right, this.direction] = arguments;
      this.master = {}
      for (var i = 0; i < arguments.length; i++) {
        this.master[functionOrder[i]] = (!isNaN(arguments[i]) ? arguments[i] * 1 : arguments[i]);
      }
      return this
    }

    //Grid class takes values from layout class to set values of Modern CSS Grid system. 
    class grid {
      constructor(parent) {
        this.gridParent = parent;
        this.gridParent.style.display = "grid";
      }
      cartesianSystem(x,y){
        function addUnits(array,units){
          const iterator = array.values();
          const newarr = [];
          for (const value of iterator) {
            newarr.push(value + units)
          }
          return newarr.join(' ');
        }
        this.gridParent.style.gridTemplateColumns = addUnits(x,'%');
        this.gridParent.style.gridTemplateRows = addUnits(y,'vh');
      }
      assignCoordinate(item, coordinates) {
        let [x1, y1, x2, y2] = coordinates;
        this.getGridBox = item;
        this.getGridBox.style.gridRowStart = x1 
        this.getGridBox.style.gridColumnStart = y1 
        this.getGridBox.style.gridRowEnd = x2 
        this.getGridBox.style.gridColumnEnd = y2 
        this.getGridBox.style.color = 'red'
      }
    }

    //Layout class processes converted 2D objects.
    
    class layout {
      constructor(material, parentElement) {
        [this.left, this.right, this.direction, this.axisTracker] = Object.values(material)
        this.material = material;
        this.grid = new grid(parentElement)
        this.parent = parentElement;
        this.areaSize();
        this.composeArea();
        this.composeCoordinates();
        this.revisingCoordinates()
      }
      areaSize(){
        this.axisTracker.map((value)=>{
          Object.values(value).splice(0,1).map((val)=>{
            if(typeof val == 'string'){
              this.mainValue = Number(val);
              this.x = [Number(val)];
              this.y = [Number(val)];
            }
          })
        })
      }
      composeArea(){
        let addLines = (direction,axisTracker) => {
          if(direction == 'perpendicular'){
            let values = Object.values(axisTracker[0]).splice(0,2)
            this.x.push(values)           
          }
          if(direction == 'parallel'){
            let values = Object.values(axisTracker[1]).splice(0,2)
            this.y.push(values)
          }
        }
        let area = (material,position,course) => {
          let axisSpliced = value => { return Object.values(value).splice(0,2)};
          addLines(material.direction,axisSpliced(material.axisTracker))
          for (let key in material) {
            if (material[key] instanceof Object && !Array.isArray(material[key])) {
              let indexOf = Object.keys(material[key]).indexOf(key);
              area(material[key],indexOf)
            }
          }
        }
        area(this.material)
        this.reviseLines(this.x,this.y);
      }
      reviseLines(x,y){
        let xA = [];
        let yA = [];
        let xAr = []
        let yAr = []
        let parentValue = this.mainValue;

        function revise(mainArray,direction,lines){
          mainArray.shift();
          mainArray.map((value,index,array)=>{
            if(value[0]+value[1] == parentValue){
              direction == 0 ? xA.push(value):yA.push(value)
            }
            else{
              direction == 0 ?xA[xA.length-1].splice(xA[xA.length-1].indexOf(value[0]+value[1]),1,value[0],value[1]):yA[yA.length-1].splice(yA[yA.length-1].indexOf(value[0]+value[1]),1,value[0],value[1])
            }
          })
          lines.forEach((value)=>{
              if(direction == 0){
                let sum = 0;
                for (let e of value){
                  sum += e;
                  xAr.push(sum)
                }
              }
              if(direction == 1){
                let sum = 0;
                for (let e of value){
                  sum += e;
                  yAr.push(sum)
                }                
              }
          })
        }
        function finalising(array){
          let filter = [...new Set(array)].sort(function(a, b){return a-b})
          filter.unshift(0)
          let final = []
          filter.forEach((value,index,array) =>{
            let num = array[index+1]-value;
            let round = Math.round(num * 100) / 100 
            final.push(round) 
          })
          final.pop()
          return final;
        }
        revise(x,0,xA)
        revise(y,1,yA)
        this.x = finalising(xAr)
        this.y = finalising(yAr)
      }
      composeCoordinates(){
        this.coordinates = new Array;
        let addCoordinates = (direction,position,cord) => {
          let x1,y1,x2,y2;
          cord?[x1,y1,x2,y2] = cord :[x1,y1,x2,y2] = [1,1,2,2]
          if (direction == 'parallel') {
            let mx1 = x1 + position 
            let mx2 = x2 + position 
            return [mx1, y1,mx2, y2]
          }
          if (direction == 'perpendicular') {
            let my1 = y1 + position 
            let my2 = y2 + position 
            return [x1, my1,x2, my2]
          }
        }
        let compose = (material,position,course) => {
          Object.keys(material).splice(0,2).map((array,index)=>{
            if(position){
              let lastTwoArrays = this.coordinates.slice(-2)
              this.coordinates.push(addCoordinates(material.direction,index,lastTwoArrays[position]))
            }
            else{
              this.coordinates.push(addCoordinates(material.direction,index))
            }
          })
          for (let key in material) {
            if (material[key] instanceof Object && !Array.isArray(material[key])) {
              let indexOf = Object.keys(material[key]).indexOf(key);
              compose(material[key],indexOf)
            }
          }
        }
        compose(this.material)
        console.log(this.coordinates)
      }
      revisingCoordinates() {
        let coordinates = (material,position,course) => {
          Object.keys(material).splice(0,2).map((array,index)=>{})
          for (let key in material) {
            if (material[key] instanceof Object && !Array.isArray(material[key])) {
              let indexOf = Object.keys(material[key]).indexOf(key);
              coordinates(material[key],indexOf)
            }
          }
        }
        coordinates(this.material)
      }
      align(mat,recur,location,coordinates){
        
        let stack;
        recur ? stack = mat  : stack = this.material;
         
        //console.log(stack.coordinates)
        this.grid.cartesianSystem(this.x,this.y)
        //console.log(stack.direction)
        for (let key in stack) {
          if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
            let indexOf = Object.keys(stack[key]).indexOf(key)
            this.align(stack[key],true,indexOf,stack.coordinates)
          }
          if(Number.isFinite(stack[key])) {

            //this.grid.assignCoordinate(this.parent.children[loopCount], this.compose(stack.direction,loopCount+1))
          } 
        }
      }
    }

    class makeSyntax {
      constructor(a) {
        this.primaryNumber = a;
        this.composition = new Array;
        this.axisContainer = new Object;
        this.current = new Object;
        this.axisContainer.xAxis = { left: a, right: a, direction: "perpendicular" };
        this.axisContainer.yAxis = { left: a, right: a, direction: "parallel" };
      }
      placing(direction, material) {
        let obj = new Object;
        let redefine = (arr, key, anyVal) => arr.find(o => Object.values(o).includes(anyVal))?.[key]
        obj.left = (material.left instanceof Object) ? obj.left = undefined : obj.left = redefine(material.axis, 'left', material.direction)
        obj.right = (material.right instanceof Object) ? obj.right = undefined : obj.right = redefine(material.axis, 'right', material.direction)
        obj.direction = material.direction;
        obj.axisTracker = material.axis
        this.composition.push(obj);
      }
      create(object, gridValue, tracker) {
        let parentVal = object.valueOf(), axis;
        const { master, splits, isObject, ...spliced } = object;
        if (this.primaryNumber == parentVal) {
          axis = this.axisContainer;
          let left, right;
          object.master.left = (Math.round(parentVal * object.master.left) / 100)
          object.master.right = (Math.round(parentVal * object.master.right) / 100)
          if (object.direction == "perpendicular") {
            axis.xAxis = object.master
          }
          if (object.direction == "parallel") {
            axis.yAxis = object.master
          }
          object.axis = Object.values(axis)
        }
        else {
          axis = Object.assign({}, object.axis);
          object.master.left = (Math.round(gridValue * object.master.left) / 100)
          object.master.right = (Math.round(gridValue * object.master.right) / 100)
          if (object.direction == "perpendicular") {
            axis[0] = object.master
          }
          if (object.direction == "parallel") {
            axis[1] = object.master
          }
          object.axis = Object.values(axis)
        }
        this.placing(object.direction, object)
        for (let key in spliced) {
          if (spliced[key] instanceof Object && !Array.isArray(spliced[key])) {
            spliced[key].axis = object.axis
            //console.log(object[key])
            let find = (direction, gridName) => {
              let value;
              if (direction == 'perpendicular') {
                gridName == 'left' ? value = object.axis[0].left : value = object.axis[0].right
              }
              if (direction == 'parallel') {
                gridName == 'left' ? value = object.axis[1].left : value = object.axis[1].right
              }
              return value
            }
            this.create(spliced[key], find(object[key].direction, key))
          }
        }
        return this.composition
      }
      tree(array) {
      let obj = array.shift();
      for (let [key, value] of Object.entries(obj)) {
        if (value === undefined) {
          obj[key] = tree(array);
        }
      }
      return obj;
      }
    }

    function tree(array) {
      let obj = array.shift();
      for (let [key, value] of Object.entries(obj)) {
        if (value === undefined) {
          obj[key] = tree(array);
        }
      }
      return obj;
    }


    
    var leftside = lg.splits(lg, sm, "perpendicular");
    var rightside = sm.splits(lg,sm.splits(lg, sm, "perpendicular"), 'parallel')
    var exp = /([\d]+)/;



    const layouts = []
    const synthesis = []
    const composeObject =[]
    const lay = []
    const nodeList = document.querySelectorAll("div[layout]");
    for (let i = 0; i < nodeList.length; i++) {
      var att = nodeList[i].getAttribute("layout")
      composeObject[i] = eval(att)
      layouts[i] = new makeSyntax(att.match(exp)[0])
      synthesis[i] = tree(layouts[i].create(composeObject[i]))
      lay[i] = new layout(synthesis[i],nodeList[i])
      lay[i].align()
      //console.log(lay)
      console.log(nodeList[i])
    }

    //let composeObject = (100).splits(lg, rightside, "perpendicular")


    //console.log(lay[0].v,lay[0].h)
    console.log(synthesis[0])




</script>


</body>

</html>