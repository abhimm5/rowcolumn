<!--

  Unnamed JavaScipt Framework
  { -- PROJECT RAC -- } 
  Commenced Aug/September, 2020
  R&D Started April/June, 2021
  Ends on : 
  Status: working.

  works left
  making coordinates
  revising coordinates
  assigning coordinates


  Below <div>s are for testing purpose:

  <div class="grid-container" id="grid-container" layout="(100).splits(lg.splits(sm,lg,'parallel'),sm.splits(lg,sm.splits(lg,sm,'perpendicular'),'parallel'),'perpendicular')">

  <div class="grid-container" id="grid-container" layout="(100).splits(lg ,sm.splits(lg,sm ,'perpendicular'),'perpendicular')">

  <div class="grid-container" id="grid-container" layout="(100).splits(lg ,sm.splits(lg,sm ,'parallel'),'perpendicular')">

-->



<!DOCTYPE html>
<html>

<head>
  <style type="text/css" id="dcoder_stylesheet">
    .grid-container>div {
      border: 1px solid #ccc;
    }
    body {
      margin: 0;
      padding: 0;
    }
  </style>
</head>

<body>

  <div class="grid-container" id="grid-container" layout="(100).splits(lg.splits(lg.splits(lg,sm.splits(sm,lg,'perpendicular') ,'parallel'),sm ,'perpendicular'), sm.splits(sm,lg,'parallel'),'perpendicular')">
    <div>1</div>
    <div>2</div>
    <div>3</div>
    <div>4</div>
    <div>5</div>
    <div></div>
    <div></div>
    <div></div>
    <div>5</div>
    <div></div>
    <div></div>
    <div></div>
  </div>

 

<script type="text/javascript">

  // let vtotal = v.length + 1
  // let htotal = h.length + 1

    let priVal = 100
    const ratio = 1.618;
    const parent = 100;
    const lg = 61.2;
    const sm = 38.8;

    const vp = ["vw", "vh"];
    const directionKeywords = ["perpendicular", "parallel", "both", "none"];
    const units = ["vh", "%", "em"];
    const baseNums = [38.2, 61.8, 100, 1.618, 0];
    const functionOrder = ["left", "right", "direction", "rotation", "modify", "clear"];
    const gridKeywords = ['verGrids', 'horGrids']
    Number.prototype.splits = function (a, b, c) {
      if (!arguments) { return }
      [this.left, this.right, this.direction] = arguments;
      this.master = {}
      for (var i = 0; i < arguments.length; i++) {
        this.master[functionOrder[i]] = (!isNaN(arguments[i]) ? arguments[i] * 1 : arguments[i]);
      }
      return this
    }

    //Grid class takes values from layout class to set values of Modern CSS Grid system. 
    class grid {
      constructor(parent) {
        this.gridParent = parent;
        this.gridParent.style.display = "grid";
      }
      cartesianSystem(x,y){
        function addUnits(array,units){
          const iterator = array.values();
          const newarr = [];
          for (const value of iterator) {
            newarr.push(value + units)
          }
          return newarr.join(' ');
        }
        this.gridParent.style.gridTemplateColumns = addUnits(x,'%');
        this.gridParent.style.gridTemplateRows = addUnits(y,'vh');
      }
      assignCoordinate(item, coordinates) {
        let [x1, y1, x2, y2] = coordinates;
        this.getGridBox = item;
        this.getGridBox.style.gridRowStart = x1 
        this.getGridBox.style.gridColumnStart = y1 
        this.getGridBox.style.gridRowEnd = x2 
        this.getGridBox.style.gridColumnEnd = y2 
        this.getGridBox.style.color = 'red'
      }
    }

    //Layout class processes converted 2D objects.
    
    class layout {
      constructor(material, parentElement) {
        [this.left, this.right, this.direction, this.axisTracker] = Object.values(material)
        this.material = material;
        this.grid = new grid(parentElement);
        this.parent = parentElement;
        this.quadrilateral = new Array;
        this.areaSize();
        this.composeArea();
        this.grid.cartesianSystem(this.x,this.y)
        this.composeDimension();
        this.composeQuadrilateral();
        this.coordinate();
      }
      areaSize(){
        console.log(this.axisTracker)
        this.axisTracker.map((value)=>{
          Object.values(value).splice(0,1).map((val)=>{
            if(typeof val == 'string'){
              this.mainValue = Number(val);
              this.x = [Number(val)];
              this.y = [Number(val)];
            }
          })
        })
      }
      composeArea(){
        let addLines = (direction,axisTracker) => {
          if(direction == 'perpendicular'){
            let values = Object.values(axisTracker[0]).splice(0,2)
            this.x.push(values)           
          }
          if(direction == 'parallel'){
            let values = Object.values(axisTracker[1]).splice(0,2)
            this.y.push(values)
          }
        }
        let area = (material,position,course) => {
          let axisSpliced = value => { return Object.values(value).splice(0,2)};
          addLines(material.direction,axisSpliced(material.axisTracker))
          for (let key in material) {
            if (material[key] instanceof Object && !Array.isArray(material[key])) {
              let indexOf = Object.keys(material[key]).indexOf(key);
              area(material[key],indexOf)
            }
          }
        }
        area(this.material)
        this.reviseLines(this.x,this.y);
      }
      reviseLines(x,y){
        let xA = [];
        let yA = [];
        let xAr = []
        let yAr = []
        let parentValue = this.mainValue;

        function revise(mainArray,direction,lines){
          mainArray.shift();
          mainArray.map((value,index,array)=>{
            if(value[0]+value[1] == parentValue){
              direction == 0 ? xA.push(value):yA.push(value)
            }
            else{
              direction == 0 ?xA[xA.length-1].splice(xA[xA.length-1].indexOf(value[0]+value[1]),1,value[0],value[1]):yA[yA.length-1].splice(yA[yA.length-1].indexOf(value[0]+value[1]),1,value[0],value[1])
            }
          })
          lines.forEach((value)=>{
              if(direction == 0){
                let sum = 0;
                for (let e of value){
                  sum += e;
                  xAr.push(sum)
                }
              }
              if(direction == 1){
                let sum = 0;
                for (let e of value){
                  sum += e;
                  yAr.push(sum)
                }                
              }
          })
        }
        function finalising(array){
          let filter = [...new Set(array)].sort(function(a, b){return a-b})
          filter.unshift(0)
          let final = []
          filter.forEach((value,index,array) =>{
            let num = array[index+1]-value;
            let round = Math.round(num * 100) / 100 
            final.push(round) 
          })
          final.pop()
          if(final.length == 0){
            final.push(parentValue)
          }
          return final;
        }
        revise(x,0,xA)
        revise(y,1,yA)
        this.x = finalising(xAr)
        this.y = finalising(yAr)
      }
      composeDimension(mat,recur,position,course){
        let stack;
        recur ? stack = mat  : stack = this.material;
        stack.area = [];
        //console.log(this)
        let getArea = (index) => {
          let l = Object.values(stack.axisTracker[0]).splice(0,2)[index];
          let h = Object.values(stack.axisTracker[1]).splice(0,2)[index];
          return [l,h].map((value)=>{return Number(value)});
          }
        for (let key in stack) {
          if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
            let indexOf = Object.keys(stack).indexOf(key)
            stack.area.push(getArea(indexOf))
            this.composeDimension(stack[key],true,key,stack.direction)
          }
          if(Number.isFinite(stack[key])) {
            let indexOf = Object.keys(stack).indexOf(key)
            stack.area.push(getArea(indexOf))
            //this.material = stack
            //console.log(this.material)
          } 
        }
      }
      composeQuadrilateral(mat,recur,position,course){
        let stack;
        recur ? stack = mat  : stack = this.material;
        let checkFull = stack.area[0].find(val => {return val==100})
        this.quadrilateral.map(value => {
          if(value.direction == 'perpendicular'){
            this.quadrilateral.pop(value) 
          }
        })
        for (let key in stack) {
          if (stack[key] instanceof Object && !Array.isArray(stack[key])) {
            let indexOf = Object.keys(stack[key]).indexOf(key)
            if(stack.direction == this.material.direction && checkFull){
              this.quadrilateral.push(stack[key])
            }
            this.composeQuadrilateral(stack[key],true,indexOf,stack.coordinates)
          }
          if(Number.isFinite(stack[key])) {
            if(stack.direction == this.material.direction && checkFull){
              this.quadrilateral.push(stack[key])
            }
          }
        }
      }
      coordinate(){
        let defaultCoordinate = [1,1,2,2]
        let composeCoordinates = (coordinates,direction) => {
          let x1,y1,x2,y2;
          [x1,y1,x2,y2] = coordinates
          if (direction == 'parallel'||direction == 1) {
            let mx1 = x2 
            let mx2 = mx1 +1 
            return [mx1, y1,mx2, y2]
          }
          if (direction == 'perpendicular'||direction == 0) {
            let my1 = y2 
            let my2 = my1 + 1 
            return [x1, my1,x2, my2]
          }
        }
        console.log(this.quadrilateral)
      }
      align(mat,recur,position,course){
        for (let key in this.material) {
          if(Number.isFinite(this.material[key])) {
            //To to finalized.
          } 
        }
        
      }

    }

    class Syntax {
      constructor(a) {
      this.primaryNumber = a;
      this.composition = new Array;
      this.axisContainer = new Object;
      this.current = new Object;
      this.axisContainer.xAxis = { left: a, right: a, direction: "perpendicular" };
      this.axisContainer.yAxis = { left: a, right: a, direction: "parallel" };
      this.objectList = new Array;
    }
    placing(direction,material){
      let obj = new Object;
      let redefine  = (arr, key, anyVal) => arr.find(o => Object.values(o).includes(anyVal))?.[key]
      obj.left = (material.left instanceof Object)? obj.left = undefined:obj.left = redefine(material.axis,'left',material.direction)
      obj.right = (material.right instanceof Object)? obj.right = undefined:obj.right = redefine(material.axis,'right',material.direction)
      obj.direction = material.direction
      obj.axisTracker = material.axis
      this.composition.push(obj);
    }
    create(object, gridValue, tracker,alteration) {
      let parentVal = object.valueOf();
      const { master, splits, isObject, ...spliced } = object;
      //console.log(spliced)
      
      if(this.primaryNumber==parentVal){
        let axis = this.axisContainer;
        this.parentDirection = object.direction;
        this.siblingDirection = object.direction == 'perpendicular' ? 'parallel':'perpendicular';
        object.master.left = (Math.round(parentVal * object.master.left) / 100)
        object.master.right = (Math.round(parentVal * object.master.right) / 100)
        if(object.direction=="perpendicular"){
          axis.xAxis = object.master
        }
        if(object.direction=="parallel"){
          axis.yAxis = object.master
        }
        object.axis = Object.values(axis)
        console.log(object)
      } 
      else{
        let axis = {xAxis:object.axis[0],yAxis:object.axis[1]};

        if(tracker){
          
          object.master.left = (Math.round(gridValue * object.master.left) / 100)
          object.master.right = (Math.round(gridValue * object.master.right) / 100)
          //console.log(tracker,object.direction)
          if(tracker=="perpendicular"){
            axis.xAxis = {left:alteration,right:alteration,direction:"perpendicular"}
            axis.yAxis = object.master
          }
          if(tracker=="parallel"){
            axis.xAxis = object.master
            axis.yAxis = {left:alteration,right:alteration,direction:"parallel"}
          }
        } 
        else{
          object.master.left = (Math.round(gridValue * object.master.left) / 100)
          object.master.right = (Math.round(gridValue * object.master.right) / 100)
          if(object.direction=="perpendicular"){
            axis.xAxis = object.master
          }
          if(object.direction=="parallel"){
            axis.yAxis = object.master
          }
        }
        
        object.axis = Object.values(axis)
        
      }

      this.placing(object.direction,object)
      this.objectList.push(object)

      for(let key in spliced){  
        
        if(spliced[key] instanceof Object&& !Array.isArray(spliced[key])){
          spliced[key].axis = object.axis
          let find = (direction,gridName) => {
            let value;
            if(direction == 'perpendicular'){
              gridName == 'left'?value = object.axis[0].left:value = object.axis[0].right
            }
            if(direction == 'parallel'){
              gridName == 'left'?value = object.axis[1].left:value = object.axis[1].right
            }
            return value
          }
          if(spliced.direction == this.parentDirection && spliced[key].direction !== this.parentDirection){
            this.create(spliced[key],find(spliced[key].direction,key),this.parentDirection,find(spliced.direction,key))
          }
          else if(spliced.direction !== this.parentDirection && spliced[key].direction == this.parentDirection){
            this.create(spliced[key],find(spliced[key].direction,key),this.siblingDirection,find(spliced.direction,key))
          }
          else{
            this.create(spliced[key],find(spliced[key].direction,key))
          }

        }
      }
      return this.composition
    }
    }

    function tree(array) {
      let obj = array.shift();
      for (let [key, value] of Object.entries(obj)) {
        if (value === undefined) {
          obj[key] = tree(array);
        }
      }
      return obj;
    }


    
    var leftside = lg.splits(lg, sm, "perpendicular");
    var rightside = sm.splits(lg,sm.splits(lg, sm, "perpendicular"), 'parallel')
    var exp = /([\d]+)/;



    const layouts = []
    const synthesis = []
    const composeObject =[]
    const lay = []
    const nodeList = document.querySelectorAll("div[layout]");
    for (let i = 0; i < nodeList.length; i++) {
      var att = nodeList[i].getAttribute("layout")
      composeObject[i] = eval(att)
      layouts[i] = new Syntax(att.match(exp)[0])
      synthesis[i] = tree(layouts[i].create(composeObject[i]))
      lay[i] = new layout(synthesis[i],nodeList[i])
      lay[i].align()
      //console.log(lay)
      console.log(nodeList[i])
    }

    //let composeObject = (100).splits(lg, rightside, "perpendicular")


    //console.log(lay[0].v,lay[0].h)
    console.log(synthesis[0])




</script>


</body>

</html>